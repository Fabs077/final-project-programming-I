<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ejercicio de Respiración - Ansiedad</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Estilos especificos de esta pagina */
        body {
            min-height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #0a1a1f;
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.1);
            z-index: 1;
        }
    </style>
</head>
<body>
    <canvas id="bg-canvas" class="exercise-canvas"></canvas>
    <div class="overlay"></div>

    <div class="content-layer">
        <div id="breathing-container">
            <div class="circle-wrapper">
                <div id="breathing-circle" class="breathing-circle"></div>
                <span id="instruction-text" class="instruction-text">Inhala</span>
            </div>
        </div>

        <div id="question-container" class="hidden">
            <h2 class="text-white text-3xl md:text-4xl font-bold mb-8 drop-shadow-lg">
                {{ config.messages.question }}
            </h2>
            <div class="flex flex-col md:flex-row gap-6 justify-center">
                <button id="btn-yes" class="btn-response btn-yes">Sí</button>
                <button id="btn-no" class="btn-response btn-no">No</button>
            </div>
        </div>

        <div id="final-message" class="hidden text-center">
            <p class="text-white text-3xl md:text-4xl font-light tracking-wide">
                {{ config.messages.success }}
            </p>
        </div>
    </div>

    <a href="/?show=main" class="back-button">← Volver</a>

    <script src="utils.js"></script>
    <script>
        // Configuracion desde parameters.py
        const CONFIG = {
            inhaleTime: {{ config.inhale_time }} * 1000,
            pauseTime: {{ config.pause_time }} * 1000,
            exhaleTime: {{ config.exhale_time }} * 1000,
            cycles: {{ config.cycles }},
            scaleMax: 2.2,
            scaleMin: 1,
            fadeTime: {{ general.fade_duration }} * 1000,
            messageTime: {{ general.message_display_time }} * 1000
        };

        // Colores desde parameters.py
        const COLORS = {
            inhale: {{ config.colors.inhale | tojson }},
            exhale: {{ config.colors.exhale | tojson }}
        };

        // Canvas - usando funciones de utils.js
        const canvas = document.getElementById('bg-canvas');
        const ctx = canvas.getContext('2d');
        setupCanvas(canvas);

        function drawBackground(color) {
            drawRadialGradient(ctx, canvas, color, 0.1, 0.15, 0.2, 0.0004);
        }

        // Elementos
        const circle = document.getElementById('breathing-circle');
        const text = document.getElementById('instruction-text');
        const breathingContainer = document.getElementById('breathing-container');
        const questionContainer = document.getElementById('question-container');
        const finalMessage = document.getElementById('final-message');

        // Estado
        let isRunning = true;
        let startTime = Date.now();
        const cycleDuration = CONFIG.inhaleTime + CONFIG.pauseTime + CONFIG.exhaleTime + CONFIG.pauseTime;
        
        // Porcentajes de cada fase
        const inhaleEnd = CONFIG.inhaleTime / cycleDuration;
        const pause1End = (CONFIG.inhaleTime + CONFIG.pauseTime) / cycleDuration;
        const exhaleEnd = (CONFIG.inhaleTime + CONFIG.pauseTime + CONFIG.exhaleTime) / cycleDuration;

        // Animacion principal
        function animate() {
            if (!isRunning) return;

            const elapsed = (Date.now() - startTime) % cycleDuration;
            const progress = elapsed / cycleDuration;
            
            let phase, phaseProgress, colorArr;
            
            if (progress < inhaleEnd) {
                // Inhalar
                phase = 'inhale';
                phaseProgress = progress / inhaleEnd;
                colorArr = COLORS.inhale;
            } else if (progress < pause1End) {
                // Pausa después de inhalar
                phase = 'pause1';
                phaseProgress = 1;
                colorArr = COLORS.inhale;
            } else if (progress < exhaleEnd) {
                // Exhalar
                phase = 'exhale';
                phaseProgress = (progress - pause1End) / (exhaleEnd - pause1End);
                colorArr = COLORS.exhale;
            } else {
                // Pausa después de exhalar
                phase = 'pause2';
                phaseProgress = 1;
                colorArr = COLORS.exhale;
            }

            const easedProgress = easeInOutCubic(phaseProgress);
            const color = getColorFromArray(colorArr, phase === 'pause1' || phase === 'pause2' ? (phase === 'pause1' ? 1 : 1) : easedProgress);

            // Dibujar fondo
            drawBackground(color);

            // Actualizar circulo
            let scale;
            if (phase === 'inhale') {
                scale = lerp(CONFIG.scaleMin, CONFIG.scaleMax, easeOutCubic(phaseProgress));
            } else if (phase === 'pause1') {
                scale = CONFIG.scaleMax;
            } else if (phase === 'exhale') {
                scale = lerp(CONFIG.scaleMax, CONFIG.scaleMin, easeInCubic(phaseProgress));
            } else {
                scale = CONFIG.scaleMin;
            }

            circle.style.transform = `scale(${scale})`;
            
            const glow = scale / CONFIG.scaleMax;
            circle.style.background = `linear-gradient(rgba(0,0,0,0.1), rgba(0,0,0,0.1)) padding-box, linear-gradient(135deg, rgb(${color.r}, ${color.g}, ${color.b}), rgb(${Math.min(255, color.r + 40)}, ${Math.min(255, color.g + 40)}, ${Math.min(255, color.b + 40)})) border-box`;
            circle.style.boxShadow = `0 0 ${50 * glow}px rgba(${color.r}, ${color.g}, ${color.b}, 0.7), 0 0 ${100 * glow}px rgba(${color.r}, ${color.g}, ${color.b}, 0.5), 0 0 ${150 * glow}px rgba(${color.r}, ${color.g}, ${color.b}, 0.3), inset 0 0 ${50 * glow}px rgba(${color.r}, ${color.g}, ${color.b}, 0.3)`;

            // Actualizar texto
            if (phase === 'inhale' || phase === 'pause1') {
                text.textContent = 'Inhala';
                text.classList.remove('text-fade-blur');
            } else {
                text.textContent = 'Exhala';
                if (phase === 'exhale' && phaseProgress > 0.5) {
                    text.classList.add('text-fade-blur');
                } else {
                    text.classList.remove('text-fade-blur');
                }
            }

            // Verificar fin
            const totalElapsed = Date.now() - startTime;
            if (totalElapsed >= cycleDuration * CONFIG.cycles) {
                showQuestion();
                return;
            }

            requestAnimationFrame(animate);
        }

        function showQuestion() {
            isRunning = false;
            breathingContainer.classList.add('fade-out');
            
            setTimeout(() => {
                breathingContainer.classList.add('hidden');
                questionContainer.classList.remove('hidden');
                questionContainer.classList.add('fade-in');
            }, CONFIG.fadeTime);

            // Seguir animando el fondo
            animateBackground();
        }

        function animateBackground() {
            const color = COLORS.exhale[COLORS.exhale.length - 1];
            drawBackground(color);
            requestAnimationFrame(animateBackground);
        }

        // Eventos de botones
        document.getElementById('btn-yes').addEventListener('click', () => {
            questionContainer.classList.add('fade-out');
            
            setTimeout(() => {
                questionContainer.classList.add('hidden');
                finalMessage.classList.remove('hidden');
                finalMessage.classList.add('fade-in');
                
                setTimeout(() => {
                    finalMessage.classList.add('fade-out');
                    setTimeout(() => {
                        window.location.href = '/?show=main';
                    }, CONFIG.fadeTime);
                }, CONFIG.messageTime);
            }, CONFIG.fadeTime);
        });

        document.getElementById('btn-no').addEventListener('click', () => {
            questionContainer.classList.add('fade-out');
            
            setTimeout(() => {
                questionContainer.classList.add('hidden');
                questionContainer.classList.remove('fade-out', 'fade-in');
                breathingContainer.classList.remove('hidden', 'fade-out');
                breathingContainer.classList.add('fade-in');
                
                // Reiniciar
                isRunning = true;
                startTime = Date.now();
                animate();
            }, CONFIG.fadeTime);
        });

        // Iniciar animación
        animate();
    </script>
</body>
</html>
